/-
Copyright (c) 2025 Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christian Merten
-/
import Mathlib.AlgebraicGeometry.Morphisms.Etale
import Mathlib.AlgebraicGeometry.Morphisms.Finite
import Mathlib.CategoryTheory.Limits.MorphismProperty
import Pi1.Mathlib.CategoryTheory.MorphismProperty.Composition
import Pi1.Mathlib.CategoryTheory.MorphismProperty.UnderAdjunction
import Pi1.Mathlib.CategoryTheory.Limits.MorphismProperty
import Pi1.Mathlib.AlgebraicGeometry.Morphisms.Etale
import Pi1.Mathlib.AlgebraicGeometry.Morphisms.Finite
import Pi1.Mathlib.AlgebraicGeometry.Morphisms.AffineAnd
import Pi1.FundamentalGroup.AffineColimits
import Pi1.Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq
import Mathlib.CategoryTheory.Limits.MorphismProperty

/-!
# Limit properties of subcategories of `P.Over ‚ä§ X` for `P = affineAnd`
-/

universe u

open CategoryTheory Limits

namespace CategoryTheory.MorphismProperty

variable {A : Type*} [Category A]
  {B : Type*} [Category B] {T : Type*} [Category T] {L L‚ÇÅ L‚ÇÇ L‚ÇÉ : A ‚•§ T} {P : MorphismProperty T}
  {Q : MorphismProperty A} {W : MorphismProperty B} [Q.IsMultiplicative] [W.IsMultiplicative]
  {R R‚ÇÅ R‚ÇÇ R‚ÇÉ : B ‚•§ T}

variable (L)

/-- The functor `Comma L R ‚•§ Comma L R` induced by the identity natural transformation on `R` is
    naturally isomorphic to the identity functor. -/
@[simps!]
def Comma.mapRightId [Q.RespectsIso] [W.RespectsIso] :
    mapRight (P := P) (Q := Q) (W := W) L (ùüô R) (fun X ‚Ü¶ by simpa using X.prop) ‚âÖ ùü≠ _ :=
  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))

/-- The functor `Comma L R‚ÇÅ ‚•§ Comma L R‚ÇÉ` induced by the composition of the natural transformations
    `r : R‚ÇÅ ‚ü∂ R‚ÇÇ` and `r' : R‚ÇÇ ‚ü∂ R‚ÇÉ` is naturally isomorphic to the composition of the functors
    induced by these natural transformations. -/
@[simps!]
def Comma.mapRightComp [Q.RespectsIso] [W.RespectsIso] (r : R‚ÇÅ ‚ü∂ R‚ÇÇ) (r' : R‚ÇÇ ‚ü∂ R‚ÇÉ)
    (hr : ‚àÄ (X : P.Comma L R‚ÇÅ Q W), P (X.hom ‚â´ r.app X.right))
    (hr' : ‚àÄ (X : P.Comma L R‚ÇÇ Q W), P (X.hom ‚â´ r'.app X.right))
    (hrr' : ‚àÄ (X : P.Comma L R‚ÇÅ Q W), P (X.hom ‚â´ (r ‚â´ r').app X.right)) :
    mapRight (P := P) (Q := Q) (W := W) L (r ‚â´ r') hrr' ‚âÖ
      mapRight L r hr ‚ãô mapRight L r' hr' :=
  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))

/-- Two equal natural transformations `R‚ÇÅ ‚ü∂ R‚ÇÇ` yield naturally isomorphic functors
    `Comma L R‚ÇÅ ‚•§ Comma L R‚ÇÇ`. -/
@[simps!]
def Comma.mapRightEq [Q.RespectsIso] [W.RespectsIso] (r r' : R‚ÇÅ ‚ü∂ R‚ÇÇ) (h : r = r')
    (hr : ‚àÄ (X : P.Comma L R‚ÇÅ Q W), P (X.hom ‚â´ r.app X.right)) :
    mapRight L r hr ‚âÖ mapRight L r' (h ‚ñ∏ hr) :=
  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))

def Comma.mapRightIso [P.RespectsIso] [Q.RespectsIso] [W.RespectsIso]
      (e : R‚ÇÅ ‚âÖ R‚ÇÇ) :
    P.Comma L R‚ÇÅ Q W ‚âå P.Comma L R‚ÇÇ Q W where
  functor := Comma.mapRight L e.hom (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
  inverse := Comma.mapRight L e.inv (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
  unitIso := (mapRightId _).symm ‚â™‚â´
    mapRightEq _ _ _ e.hom_inv_id.symm (fun X ‚Ü¶ by simpa using X.prop) ‚â™‚â´
    mapRightComp _ _ _
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
  counitIso :=
    (mapRightComp _ _ _
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop)).symm ‚â™‚â´
    mapRightEq _ _ _ e.inv_hom_id
      (fun X ‚Ü¶ (P.cancel_right_of_respectsIso _ _).mpr X.prop) ‚â™‚â´
    mapRightId _

variable {L} (R)

/-- The functor `Comma L R ‚•§ Comma L R` induced by the identity natural transformation on `R` is
    naturally isomorphic to the identity functor. -/
@[simps!]
def Comma.mapLeftId [Q.RespectsIso] [W.RespectsIso] :
    mapLeft (P := P) (Q := Q) (W := W) R (ùüô L) (fun X ‚Ü¶ by simpa using X.prop) ‚âÖ ùü≠ _ :=
  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))

/-- The functor `Comma L R‚ÇÅ ‚•§ Comma L R‚ÇÉ` induced by the composition of the natural transformations
    `r : R‚ÇÅ ‚ü∂ R‚ÇÇ` and `r' : R‚ÇÇ ‚ü∂ R‚ÇÉ` is naturally isomorphic to the composition of the functors
    induced by these natural transformations. -/
@[simps!]
def Comma.mapLeftComp [Q.RespectsIso] [W.RespectsIso] (l : L‚ÇÅ ‚ü∂ L‚ÇÇ) (l' : L‚ÇÇ ‚ü∂ L‚ÇÉ)
    (hl : ‚àÄ (X : P.Comma L‚ÇÇ R Q W), P (l.app X.left ‚â´ X.hom))
    (hl' : ‚àÄ (X : P.Comma L‚ÇÉ R Q W), P (l'.app X.left ‚â´ X.hom))
    (hll' : ‚àÄ (X : P.Comma L‚ÇÉ R Q W), P ((l ‚â´ l').app X.left ‚â´ X.hom)) :
    mapLeft (P := P) (Q := Q) (W := W) R (l ‚â´ l') hll' ‚âÖ
      mapLeft R l' hl' ‚ãô mapLeft R l hl :=
  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))

/-- Two equal natural transformations `R‚ÇÅ ‚ü∂ R‚ÇÇ` yield naturally isomorphic functors
    `Comma L R‚ÇÅ ‚•§ Comma L R‚ÇÇ`. -/
@[simps!]
def Comma.mapLeftEq [Q.RespectsIso] [W.RespectsIso] (l l' : L‚ÇÅ ‚ü∂ L‚ÇÇ) (h : l = l')
    (hl : ‚àÄ (X : P.Comma L‚ÇÇ R Q W), P (l.app X.left ‚â´ X.hom)) :
    mapLeft R l hl ‚âÖ mapLeft R l' (h ‚ñ∏ hl) :=
  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _))

@[simps!]
def Comma.mapLeftIso [P.RespectsIso] [Q.RespectsIso] [W.RespectsIso]
      (e : L‚ÇÅ ‚âÖ L‚ÇÇ) :
    P.Comma L‚ÇÅ R Q W ‚âå P.Comma L‚ÇÇ R Q W where
  functor := Comma.mapLeft R e.inv (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
  inverse := Comma.mapLeft R e.hom (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
  unitIso := (mapLeftId _).symm ‚â™‚â´
    mapLeftEq _ _ _ e.hom_inv_id.symm (fun X ‚Ü¶ by simpa using X.prop) ‚â™‚â´
    mapLeftComp _ _ _
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
  counitIso :=
    (mapLeftComp _ _ _
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop)).symm ‚â™‚â´
    mapLeftEq _ _ _ e.inv_hom_id
      (fun X ‚Ü¶ (P.cancel_left_of_respectsIso _ _).mpr X.prop) ‚â™‚â´
    mapLeftId _

variable {C : Type*} [Category C] (P Q : MorphismProperty C) [Q.IsMultiplicative]

def Over.congr [P.RespectsIso] [Q.RespectsIso] {X Y : C} (e : X ‚âÖ Y) :
    P.Over Q X ‚âå P.Over Q Y :=
  Comma.mapRightIso _ (Discrete.natIso fun _ ‚Ü¶ e)

@[simps!]
def Under.congr [P.RespectsIso] [Q.RespectsIso] {X Y : C} (e : X ‚âÖ Y) :
    P.Under Q X ‚âå P.Under Q Y :=
  Comma.mapLeftIso _ (Discrete.natIso fun _ ‚Ü¶ e)

@[simps]
noncomputable def pushoutIsoOfIso [HasPushouts C] {X Y X' Y' Z : C} {f : X ‚ü∂ Y} {f' : X' ‚ü∂ Y'}
    (e : Arrow.mk f ‚âÖ Arrow.mk f') (g : X ‚ü∂ Z) :
    pushout g f ‚âÖ pushout (e.inv.left ‚â´ g) f' where
  hom := pushout.map _ _ _ _ (ùüô Z) e.hom.right e.hom.left (by simp) (by simp)
  inv := pushout.map _ _ _ _ (ùüô Z) e.inv.right e.inv.left (by simp) (by simp)

noncomputable
def Under.congrPushoutIso [HasPushouts C] [P.IsStableUnderCobaseChange]
    [Q.IsStableUnderCobaseChange] [Q.RespectsIso]
    {X X' Y Y' : C} (f : X ‚ü∂ Y) (f' : X' ‚ü∂ Y') (eX : X ‚âÖ X') (eY : Y ‚âÖ Y')
    (h : f ‚â´ eY.hom = eX.hom ‚â´ f') :
    (Under.congr P Q eX).functor ‚ãô Under.pushout P Q f' ‚âÖ
      Under.pushout P Q f ‚ãô (Under.congr P Q eY).functor :=
  NatIso.ofComponents
    (fun A ‚Ü¶ Under.isoMk ((pushoutIsoOfIso (Arrow.isoMk eX eY h.symm) A.hom).symm)) <|
    fun {A B} g ‚Ü¶ by
      ext
      apply pushout.hom_ext <;> simp [Under.pushout]

end CategoryTheory.MorphismProperty

section

variable {R : CommRingCat.{u}} {Œπ : Type} (P : Œπ ‚Üí Under R)

namespace CommRingCat

variable {Œπ : Type} (R : Œπ ‚Üí CommRingCat.{u})

/--
The categorical product of rings is the cartesian product of rings. This is its `Fan`.
-/
@[simps! pt]
def piFan' : Fan R :=
  Fan.mk (CommRingCat.of ((i : Œπ) ‚Üí R i)) (fun i ‚Ü¶ ofHom <| Pi.evalRingHom _ i)

/--
The categorical product of rings is the cartesian product of rings.
-/
def piFanIsLimit' : IsLimit (piFan' R) where
  lift s := ofHom <| Pi.ringHom fun i ‚Ü¶ (s.œÄ.1 ‚ü®i‚ü©).hom
  fac s i := by rfl
  uniq _ _ h := hom_ext <| DFunLike.ext _ _ fun x ‚Ü¶ funext fun i ‚Ü¶
    DFunLike.congr_fun (congrArg Hom.hom <| h ‚ü®i‚ü©) x

end CommRingCat

namespace CommRingCat.Under

/-- The canonical fan on `P : Œπ ‚Üí Under R` given by `‚àÄ i, P i`. -/
def piFan' : Fan P :=
  Fan.mk (Under.mk <| ofHom <| Pi.ringHom (fun i ‚Ü¶ (P i).hom.hom))
    (fun i ‚Ü¶ Under.homMk (ofHom <| Pi.evalRingHom _ i))

/-- The canonical fan is limiting. -/
noncomputable def piFanIsLimit' : IsLimit (piFan' P) :=
  isLimitOfReflects (Under.forget R) <|
    (isLimitMapConeFanMkEquiv (Under.forget R) P _).symm <|
      CommRingCat.piFanIsLimit' (fun i ‚Ü¶ (P i).right)

end CommRingCat.Under

end

namespace RingHom

variable {Q : ‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop}

-- TODO: reformulate these with ringhoms?

/-- A property of ring homomorphisms `Q` is said to have equalizers, if the equalizer of algebra
maps between algebras satisfiying `Q` also satisfies `Q`. -/
def HasEqualizers (Q : ‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop) : Prop :=
  ‚àÄ {R S T : Type u} [CommRing R] [CommRing S] [CommRing T] [Algebra R S] [Algebra R T]
    (f g : S ‚Üí‚Çê[R] T), Q (algebraMap R S) ‚Üí Q (algebraMap R T) ‚Üí
      Q (algebraMap R (AlgHom.equalizer f g))

def HasFiniteProducts (Q : ‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop) : Prop :=
  ‚àÄ {R : Type u} [CommRing R] {Œπ : Type} [_root_.Finite Œπ] (S : Œπ ‚Üí Type u) [‚àÄ i, CommRing (S i)]
    [‚àÄ i, Algebra R (S i)],
    (‚àÄ i, Q (algebraMap R (S i))) ‚Üí Q (algebraMap R (Œ† i, S i))

end RingHom

namespace AlgebraicGeometry

variable {Q : ‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop}
variable (P : MorphismProperty Scheme.{u}) [HasAffineProperty P (affineAnd Q)]

namespace AffineAnd

open MorphismProperty

variable {X : Scheme.{u}}

instance (f : P.Over ‚ä§ X) : IsAffineHom f.hom :=
  HasAffineProperty.affineAnd_le_isAffineHom P inferInstance _ f.2

def toAffine (X : Scheme.{u}) : P.Over ‚ä§ X ‚•§ Affine X where
  obj f := ‚ü®f.toComma, inferInstance‚ü©
  map f := ‚ü®f.toCommaMorphism, trivial, trivial‚ü©

def toAffineFullyFaithful (X : Scheme.{u}) : (toAffine P X).FullyFaithful where
  preimage f := ‚ü®f.toCommaMorphism, trivial, trivial‚ü©

instance : (toAffine P X).Faithful := (toAffineFullyFaithful P X).faithful
instance : (toAffine P X).Full := (toAffineFullyFaithful P X).full

variable [P.IsStableUnderBaseChange]

variable (J : Type) [SmallCategory J] [FinCategory J]

noncomputable
def _root_.CommRingCat.Under.createsFiniteProductsForget (hQi : RingHom.RespectsIso Q)
    (hQp : RingHom.HasFiniteProducts Q) (R : CommRingCat.{u}) :
    CreatesFiniteProducts (MorphismProperty.Under.forget (RingHom.toMorphismProperty Q) ‚ä§ R) := by
  refine ‚ü®fun J _ ‚Ü¶ Comma.forgetCreatesLimitsOfShapeOfClosed _ <| ?_‚ü©
  intro (D : Discrete J ‚•§ Under R) c hc hD
  let e : c.pt ‚âÖ CommRingCat.mkUnder R (Œ† i, D.obj ‚ü®i‚ü©) :=
    (limit.isoLimitCone ‚ü®c, hc‚ü©).symm ‚â™‚â´
      HasLimit.isoOfNatIso (Discrete.natIso fun i ‚Ü¶ eqToIso <| by simp) ‚â™‚â´
      limit.isoLimitCone ‚ü®CommRingCat.Under.piFan' <| fun i ‚Ü¶ (D.obj ‚ü®i‚ü©),
        CommRingCat.Under.piFanIsLimit' <| fun i ‚Ü¶ (D.obj ‚ü®i‚ü©)‚ü©
  have := Under.w e.inv
  rw [‚Üê this]
  have : (RingHom.toMorphismProperty Q).RespectsIso :=
    RingHom.toMorphismProperty_respectsIso_iff.mp hQi
  rw [MorphismProperty.cancel_right_of_respectsIso (P := RingHom.toMorphismProperty Q)]
  exact hQp _ fun i ‚Ü¶ hD ‚ü®i‚ü©

lemma _root_.CommRingCat.Under.hasFiniteProducts (hQi : RingHom.RespectsIso Q)
    (hQp : RingHom.HasFiniteProducts Q) (R : CommRingCat.{u}) :
    HasFiniteProducts ((RingHom.toMorphismProperty Q).Under ‚ä§ R) := by
  refine ‚ü®fun n ‚Ü¶ ‚ü®fun D ‚Ü¶ ?_‚ü©‚ü©
  have := CommRingCat.Under.createsFiniteProductsForget hQi hQp R
  exact CategoryTheory.hasLimit_of_created D (Under.forget _ _ R)

noncomputable
def _root_.CommRingCat.Under.createsEqualizersForget (hQi : RingHom.RespectsIso Q)
    (hQe : RingHom.HasEqualizers Q) (R : CommRingCat.{u}) :
    CreatesLimitsOfShape WalkingParallelPair
      (MorphismProperty.Under.forget (RingHom.toMorphismProperty Q) ‚ä§ R) := by
  apply Comma.forgetCreatesLimitsOfShapeOfClosed
  intro (D : WalkingParallelPair ‚•§ Under R) c hc hD
  let e : c.pt ‚âÖ
      CommRingCat.mkUnder R
        (AlgHom.equalizer (R := R)
          (CommRingCat.toAlgHom (D.map .left))
          (CommRingCat.toAlgHom (D.map .right))) :=
    (limit.isoLimitCone ‚ü®c, hc‚ü©).symm ‚â™‚â´
      HasLimit.isoOfNatIso (diagramIsoParallelPair _) ‚â™‚â´ limit.isoLimitCone
        ‚ü®CommRingCat.Under.equalizerFork (D.map .left) (D.map .right),
          CommRingCat.Under.equalizerForkIsLimit
            (D.map .left) (D.map .right)‚ü©
  have := Under.w e.inv
  rw [‚Üê this]
  have : (RingHom.toMorphismProperty Q).RespectsIso :=
    RingHom.toMorphismProperty_respectsIso_iff.mp hQi
  rw [MorphismProperty.cancel_right_of_respectsIso (P := RingHom.toMorphismProperty Q)]
  exact hQe _ _ (hD .zero) (hD .one)

noncomputable
def _root_.CommRingCat.Under.createsFiniteLimitsForget (hQi : RingHom.RespectsIso Q)
    (hQp : RingHom.HasFiniteProducts Q) (hQe : RingHom.HasEqualizers Q) (R : CommRingCat.{u}) :
    CreatesFiniteLimits (Under.forget (RingHom.toMorphismProperty Q) ‚ä§ R) := by
  have := CommRingCat.Under.createsFiniteProductsForget hQi hQp
  have := CommRingCat.Under.createsEqualizersForget hQi hQe
  apply createsFiniteLimitsOfCreatesEqualizersAndFiniteProducts

lemma _root_.CommRingCat.Under.hasEqualizers (hQi : RingHom.RespectsIso Q)
    (hQe : RingHom.HasEqualizers Q) (R : CommRingCat.{u}) :
    HasEqualizers ((RingHom.toMorphismProperty Q).Under ‚ä§ R) := by
  refine ‚ü®fun D ‚Ü¶ ?_‚ü©
  have := CommRingCat.Under.createsEqualizersForget hQi hQe R
  exact CategoryTheory.hasLimit_of_created D (Under.forget _ _ R)

lemma _root_.CommRingCat.Under.hasFiniteLimits (hQi : RingHom.RespectsIso Q)
    (hQp : RingHom.HasFiniteProducts Q) (hQe : RingHom.HasEqualizers Q) (R : CommRingCat.{u}) :
    HasFiniteLimits ((RingHom.toMorphismProperty Q).Under ‚ä§ R) :=
  have := CommRingCat.Under.hasFiniteProducts hQi hQp
  have := CommRingCat.Under.hasEqualizers hQi hQe
  hasFiniteLimits_of_hasEqualizers_and_finite_products

lemma _root_.CommRingCat.Under.property_limit_of_hasFiniteProducts_of_hasEqualizers
    (hQi : RingHom.RespectsIso Q) (hQp : RingHom.HasFiniteProducts Q)
    (hQe : RingHom.HasEqualizers Q)
    {R : CommRingCat.{u}} (D : J ‚•§ Under R) (h : ‚àÄ j, Q (D.obj j).hom.hom) :
    Q (limit D).hom.hom := by
  have := CommRingCat.Under.hasFiniteLimits hQi hQp hQe
  let D' : J ‚•§ (RingHom.toMorphismProperty Q).Under ‚ä§ R :=
    MorphismProperty.Comma.lift D h (by simp) (by simp)
  let A := limit D'
  have : CreatesFiniteLimits (Under.forget (RingHom.toMorphismProperty Q) ‚ä§ R) :=
    CommRingCat.Under.createsFiniteLimitsForget hQi hQp hQe R
  let e : (Under.forget _ _ R).obj A ‚âÖ limit D :=
    preservesLimitIso (Under.forget (RingHom.toMorphismProperty Q) ‚ä§ R) D'
  have := CategoryTheory.Under.w e.hom
  rw [‚Üê this, CommRingCat.hom_comp, hQi.cancel_right_isIso]
  exact A.prop

noncomputable
def createsFiniteColimits (hQi : RingHom.RespectsIso Q) (hQp : RingHom.HasFiniteProducts Q)
    (hQe : RingHom.HasEqualizers Q) :
    CreatesFiniteColimits (toAffine P X) := by
  constructor
  intro J _ _
  constructor
  intro D
  let D' : J ‚•§ Affine X := D ‚ãô toAffine P X
  have : HasColimit D' := inferInstance
  have : P (colimit D').hom := by
    rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]
    dsimp
    intro U
    simp only [morphismRestrict]
    rw [P.cancel_left_of_respectsIso]
    show P <| ((Affine.pullback U.1.Œπ).obj (colimit D')).hom
    let i : (Affine.pullback U.1.Œπ).obj (colimit D') ‚âÖ
        colimit (D' ‚ãô Affine.pullback U.1.Œπ) :=
      preservesColimitIso (Affine.pullback U.1.Œπ) D'
    erw [P.over_iso_iff ((MorphismProperty.Comma.forget _ _ _ _ _).mapIso i)]
    simp only [Comma.forget_obj, Functor.id_obj, Functor.const_obj_obj]
    let i‚ÇÇ : (Affine.Œì U.1).rightOp.obj (colimit (D' ‚ãô Affine.pullback U.1.Œπ)) ‚âÖ
        colimit (D' ‚ãô Affine.pullback U.1.Œπ ‚ãô (Affine.Œì U.1).rightOp) :=
      preservesColimitIso (Affine.Œì U.1).rightOp (D' ‚ãô Affine.pullback U.1.Œπ)
    let i‚ÇÉ : ((Affine.Œì U.1).rightOp.obj (colimit (D' ‚ãô Affine.pullback U.1.Œπ))).unop ‚âÖ
        (colimit (D' ‚ãô Affine.pullback U.1.Œπ ‚ãô (Affine.Œì U.1).rightOp)).unop :=
      i‚ÇÇ.symm.unop
    let i‚ÇÑ : ((Affine.Œì U.1).rightOp.obj (colimit (D' ‚ãô Affine.pullback U.1.Œπ))).unop ‚âÖ
        limit (D' ‚ãô Affine.pullback U.1.Œπ ‚ãô (Affine.Œì U.1).rightOp).leftOp :=
      i‚ÇÉ ‚â™‚â´ (limitLeftOpIsoUnopColimit
        (D' ‚ãô Affine.pullback U.1.Œπ ‚ãô (Affine.Œì ‚Üë‚ÜëU).rightOp)).symm
    have := CategoryTheory.Under.w i‚ÇÑ.inv
    rw [HasAffineProperty.iff_of_isAffine (P := P)]
    simp
    constructor
    ¬∑ infer_instance
    have heq : (colimit (D' ‚ãô Affine.pullback U.1.Œπ)).hom.appTop =
        ((Affine.Œì U.1).rightOp.obj (colimit (D' ‚ãô Affine.pullback U.1.Œπ))).unop.hom := rfl
    rw [heq, ‚Üê this, CommRingCat.hom_comp]
    simp only [Functor.id_obj, Functor.rightOp_obj]
    rw [hQi.cancel_right_isIso]
    apply _root_.CommRingCat.Under.property_limit_of_hasFiniteProducts_of_hasEqualizers
    ¬∑ exact hQi
    ¬∑ exact hQp
    ¬∑ exact hQe
    ¬∑ intro ‚ü®j‚ü©
      have : P (pullback.snd (D'.obj j).hom U.1.Œπ) := P.pullback_snd _ _ (D.obj j).prop
      rw [HasAffineProperty.iff_of_isAffine (P := P)] at this
      exact this.2
  exact CategoryTheory.createsColimitOfFullyFaithfulOfIso
    ‚ü®(colimit D').toComma, this‚ü© (eqToIso rfl)

lemma hasFiniteColimits (hQi : RingHom.RespectsIso Q) (hQp : RingHom.HasFiniteProducts Q)
    (hQe : RingHom.HasEqualizers Q) :
    HasFiniteColimits (P.Over ‚ä§ X) := by
  constructor
  intro J _ _
  constructor
  intro D
  have := createsFiniteColimits (X := X) P hQi hQp hQe
  apply CategoryTheory.hasColimit_of_created D (toAffine P X)

lemma preservesFiniteColimits_toAffine (hQi : RingHom.RespectsIso Q)
    (hQp : RingHom.HasFiniteProducts Q) (hQe : RingHom.HasEqualizers Q) :
    PreservesFiniteColimits (toAffine P X) := by
  have := hasFiniteColimits (X := X) P hQi hQp hQe
  have := createsFiniteColimits (X := X) P hQi hQp hQe
  infer_instance

theorem preservesFiniteLimits_pullback
    [P.IsStableUnderComposition] [P.ContainsIdentities]
    [P.HasOfPostcompProperty P] {Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    PreservesFiniteLimits (MorphismProperty.Over.pullback P ‚ä§ f) := by
  infer_instance

@[simps!]
def _root_.AlgebraicGeometry.IsAffineOpen.ŒìProp
    (hQi : RingHom.RespectsIso Q)
    {S : Scheme.{u}} {U : S.Opens} (hU : IsAffineOpen U) :
    (P.Over ‚ä§ S)·µí·µñ ‚•§ (RingHom.toMorphismProperty Q).Under ‚ä§ Œì(S, U) where
  obj X := MorphismProperty.Under.mk _ (X.unop.hom.app U) <| by
    have : targetAffineLocally (affineAnd Q) X.unop.hom := by
      rw [‚Üê HasAffineProperty.eq_targetAffineLocally P]
      exact X.unop.prop
    rw [targetAffineLocally_affineAnd_iff hQi] at this
    exact (this U hU).2
  map {X Y} f := MorphismProperty.Under.homMk
      (f.unop.left.appLE (X.unop.hom ‚Åª¬π·µÅ U) (Y.unop.hom ‚Åª¬π·µÅ U)
      (by rw [‚Üê Scheme.preimage_comp, CategoryTheory.Over.w])) <| by
    simp [Scheme.Hom.app_eq_appLE, Scheme.appLE_comp_appLE]
  map_id X := by
    ext : 1
    simp only [Functor.id_obj, Functor.const_obj_obj, id_eq, eq_mpr_eq_cast, eq_mp_eq_cast,
      Scheme.comp_coeBase, TopologicalSpace.Opens.map_comp_obj, cast_eq, Scheme.Hom.appLE,
      homOfLE_leOfHom, homOfLE_refl, op_id, Scheme.comp_app, unop_id, Comma.id_hom,
      CategoryTheory.Comma.id_left, Scheme.id.base, Scheme.id_app, Category.id_comp,
      Under.homMk_hom, Under.homMk_right, CategoryTheory.Comma.id_right]
    apply CategoryTheory.Functor.map_id
  map_comp {X Y Z} f g := by
    ext : 1
    show Scheme.Hom.appLE (g.unop.left ‚â´ f.unop.left) _ _ _ =
      Scheme.Hom.appLE _ _ _ _ ‚â´ Scheme.Hom.appLE _ _ _ _
    rw [Scheme.appLE_comp_appLE]

@[simps! obj_hom]
def ŒìProp (hQi : RingHom.RespectsIso Q) (S : Scheme.{u}) [IsAffine S] :
    (P.Over ‚ä§ S)·µí·µñ ‚•§ (RingHom.toMorphismProperty Q).Under ‚ä§ Œì(S, ‚ä§) :=
  (isAffineOpen_top S).ŒìProp P hQi

omit [P.IsStableUnderBaseChange] in
-- `simps` generates this with `appLE` on the RHS
@[simp]
lemma ŒìProp_map_right (hQi : RingHom.RespectsIso Q) (S : Scheme.{u}) [IsAffine S]
    {X Y : (P.Over ‚ä§ S)·µí·µñ} (f : X ‚ü∂ Y) :
    ((ŒìProp P hQi S).map f).right = f.unop.left.appTop := by
  simpa [ŒìProp, IsAffineOpen.ŒìProp, Scheme.Hom.appTop] using
    (Scheme.Hom.app_eq_appLE ..).symm

lemma _root_.AlgebraicGeometry.Scheme.Hom.appTop_bijective_of_isAffine
      {X Y : Scheme.{u}} [IsAffine X] [IsAffine Y] :
    Function.Bijective (fun (f : X ‚ü∂ Y) ‚Ü¶ f.appTop) := by
  refine ‚ü®fun f g (hfg : f.appTop = g.appTop) ‚Ü¶ ?_, fun f ‚Ü¶ ?_‚ü©
  ¬∑ have (f : X ‚ü∂ Y) : f = X.isoSpec.hom ‚â´ Spec.map f.appTop ‚â´ Y.isoSpec.inv := by
      simp [Scheme.isoSpec_hom_naturality_assoc]
    rw [this f, this g, hfg]
  ¬∑ use X.isoSpec.hom ‚â´ Spec.map f ‚â´ Y.isoSpec.inv
    simp [Scheme.isoSpec]

omit [P.IsStableUnderBaseChange] in
lemma faithful_ŒìProp (hQi : RingHom.RespectsIso Q) {S : Scheme.{u}} [IsAffine S] :
    (ŒìProp P hQi S).Faithful where
  map_injective := by
    intro ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®f‚ü© ‚ü®g‚ü© hfg
    have : f = g := by
      ext : 1
      have : IsAffine X.left := isAffine_of_isAffineHom (Y := S) X.hom
      have : IsAffine Y.left := isAffine_of_isAffineHom (Y := S) Y.hom
      apply AlgebraicGeometry.Scheme.Hom.appTop_bijective_of_isAffine.injective
      simpa using congr($(hfg).right)
    rw [this]

omit [P.IsStableUnderBaseChange] in
lemma full_ŒìProp (hQi : RingHom.RespectsIso Q) {S : Scheme.{u}} [IsAffine S] :
    (ŒìProp P hQi S).Full where
  map_surjective := by
    intro ‚ü®X‚ü© ‚ü®Y‚ü© f
    have : IsAffine ((ùü≠ Scheme).obj X.left) := isAffine_of_isAffineHom (Y := S) X.hom
    have : IsAffine ((ùü≠ Scheme).obj Y.left) := isAffine_of_isAffineHom (Y := S) Y.hom
    have : IsAffine ((Functor.fromPUnit S).obj X.right) := inferInstanceAs <| IsAffine S
    have : IsAffine Y.left := isAffine_of_isAffineHom (Y := S) Y.hom
    obtain ‚ü®f', h‚ü© := AlgebraicGeometry.Scheme.Hom.appTop_bijective_of_isAffine.surjective f.right
    use (MorphismProperty.Over.homMk f' <| by
      apply AlgebraicGeometry.Scheme.Hom.appTop_bijective_of_isAffine.injective
      simpa [h] using f.w.symm).op
    ext : 1
    simpa using h

omit [P.IsStableUnderBaseChange] in
lemma essSurj_ŒìProp (hQi : RingHom.RespectsIso Q) {S : Scheme.{u}} [IsAffine S] :
    (ŒìProp P hQi S).EssSurj where
  mem_essImage R := by
    let X : P.Over ‚ä§ S := MorphismProperty.Over.mk ‚ä§ (Spec.map R.hom ‚â´ S.isoSpec.inv) <| by
      rw [P.cancel_right_of_respectsIso, HasAffineProperty.SpecMap_iff_of_affineAnd (P := P) _ hQi]
      exact R.prop
      infer_instance
    refine ‚ü®‚ü®X‚ü©, ‚ü®Under.isoMk (Scheme.ŒìSpecIso _) ?_‚ü©‚ü©
    simp [X, Scheme.isoSpec]

omit [P.IsStableUnderBaseChange] in
lemma isEquivalence_ŒìProp (hQi : RingHom.RespectsIso Q) {S : Scheme.{u}} [IsAffine S] :
    (ŒìProp P hQi S).IsEquivalence where
  faithful := faithful_ŒìProp ..
  full := full_ŒìProp ..
  essSurj := essSurj_ŒìProp ..

attribute [reassoc (attr := simp)] Scheme.appLE_comp_appLE

noncomputable
def pullbackŒìPropIso [(RingHom.toMorphismProperty Q).IsStableUnderCobaseChange]
    (hQi : RingHom.RespectsIso Q) {S T : Scheme.{u}} [IsAffine S]
    [IsAffine T] (f : S ‚ü∂ T) :
    (Over.pullback P ‚ä§ f).op ‚ãô ŒìProp P hQi S ‚âÖ
      ŒìProp P hQi T ‚ãô Under.pushout _ ‚ä§ f.appTop :=
  NatIso.ofComponents
    (fun X ‚Ü¶
      haveI : IsAffine X.unop.left := isAffine_of_isAffineHom (Y := T) X.unop.hom
      Under.isoMk (ŒìpullbackIsoPushout (X := X.unop.left) (Y := S) (S := T)
        (X.unop.hom : X.unop.left ‚ü∂ T) f) <| by simp) <| fun {X Y} g ‚Ü¶ by
    ext : 1
    dsimp [MorphismProperty.Under.pushout]
    have : IsAffine ((ùü≠ Scheme).obj (Opposite.unop X).left) :=
      isAffine_of_isAffineHom (Y := T) X.unop.hom
    have : IsAffine ((Functor.fromPUnit T).obj (Opposite.unop X).right) :=
      inferInstanceAs <| IsAffine T
    rw [‚Üê cancel_epi (ŒìpullbackIsoPushout (X.unop).hom f).inv]
    apply pushout.hom_ext
    ¬∑ simp [‚Üê Scheme.comp_appTop_assoc]
    ¬∑ simp [‚Üê Scheme.comp_appTop_assoc]

@[simps!]
noncomputable
def overSpecEquivUnder (hQi : RingHom.RespectsIso Q) (R : CommRingCat.{u}) :
    (P.Over ‚ä§ (Spec R))·µí·µñ ‚âå (RingHom.toMorphismProperty Q).Under ‚ä§ R :=
  have : (RingHom.toMorphismProperty Q).RespectsIso :=
    RingHom.toMorphismProperty_respectsIso_iff.mp hQi
  have : (ŒìProp P hQi (Spec R)).IsEquivalence :=
    isEquivalence_ŒìProp P hQi
  (ŒìProp P hQi (Spec R)).asEquivalence.trans <| Under.congr _ ‚ä§ (Scheme.ŒìSpecIso R)

noncomputable
def overSpecEquivUnderCompPushoutIso (hQi : RingHom.RespectsIso Q) {R S : CommRingCat.{u}}
    (f : R ‚ü∂ S)
    [(RingHom.toMorphismProperty Q).IsStableUnderCobaseChange] :
    (overSpecEquivUnder P hQi R).functor ‚ãô
      (MorphismProperty.Under.pushout (RingHom.toMorphismProperty Q) ‚ä§ f) ‚âÖ
      (Over.pullback P ‚ä§ (Spec.map f)).op ‚ãô (overSpecEquivUnder P hQi S).functor :=
  Functor.associator _ _ _ ‚â™‚â´
    isoWhiskerLeft _ (Under.congrPushoutIso _ ‚ä§
      (Spec.map f).appTop f (Scheme.ŒìSpecIso R) (Scheme.ŒìSpecIso S) (by simp)) ‚â™‚â´
      (Functor.associator _ _ _).symm ‚â™‚â´
      isoWhiskerRight (pullbackŒìPropIso P hQi _).symm _ ‚â™‚â´
      Functor.associator _ _ _

lemma preservesColimitsOfShape_pullback_iff_preservesLimitsOfShape (hQi : RingHom.RespectsIso Q)
    {R S : CommRingCat.{u}} (f : R ‚ü∂ S) {J : Type*} [Category J]
    [(RingHom.toMorphismProperty Q).IsStableUnderCobaseChange] :
    PreservesColimitsOfShape J (Over.pullback P ‚ä§ (Spec.map f)) ‚Üî
      PreservesLimitsOfShape J·µí·µñ
        (MorphismProperty.Under.pushout (RingHom.toMorphismProperty Q) ‚ä§ f) := by
  let iso : (overSpecEquivUnder P hQi R).functor ‚ãô
      (Under.pushout (RingHom.toMorphismProperty Q) ‚ä§ f) ‚ãô
      (overSpecEquivUnder P hQi S).inverse ‚âÖ (Over.pullback P ‚ä§ (Spec.map f)).op :=
    (Functor.associator _ _ _).symm ‚â™‚â´
      isoWhiskerRight (overSpecEquivUnderCompPushoutIso P hQi f) _ ‚â™‚â´
      Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ (overSpecEquivUnder P hQi S).unitIso.symm ‚â™‚â´
      Functor.rightUnitor _
  let iso' : ((overSpecEquivUnder P hQi R).functor.rightOp ‚ãô
      (Under.pushout (RingHom.toMorphismProperty Q) ‚ä§ f).op ‚ãô
      (overSpecEquivUnder P hQi S).inverse.leftOp).op ‚âÖ (Over.pullback P ‚ä§ (Spec.map f)).op :=
    iso
  let foo := NatIso.removeOp iso'
  let e' : _ ‚âÖ (overSpecEquivUnder P (Q := Q) hQi R).inverse.leftOp ‚ãô
      (overSpecEquivUnder P (Q := Q) hQi R).functor.rightOp :=
   (NatIso.op <| (overSpecEquivUnder P (Q := Q) hQi R).counitIso)
  let e'' : _ ‚âÖ (overSpecEquivUnder P hQi S).inverse.leftOp ‚ãô
      (overSpecEquivUnder P hQi S).functor.rightOp :=
   (NatIso.op <| (overSpecEquivUnder P hQi S).counitIso)
  let iso2 : (Under.pushout (RingHom.toMorphismProperty Q) ‚ä§ f).op ‚âÖ
      (overSpecEquivUnder P hQi R).inverse.leftOp ‚ãô Over.pullback P ‚ä§ (Spec.map f) ‚ãô
      (overSpecEquivUnder P hQi S).functor.rightOp :=
    (Functor.rightUnitor _).symm ‚â™‚â´
      isoWhiskerLeft _ e'' ‚â™‚â´
      (Functor.associator _ _ _).symm ‚â™‚â´
      isoWhiskerRight (Functor.leftUnitor _).symm _ ‚â™‚â´
      isoWhiskerRight (isoWhiskerRight e' _) _ ‚â™‚â´
      isoWhiskerRight (Functor.associator _ _ _) _ ‚â™‚â´
      isoWhiskerRight (isoWhiskerLeft _ foo.symm) _ ‚â™‚â´ Functor.associator _ _ _
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ convert preservesLimitsOfShape_of_op _ _
    convert preservesColimitsOfShape_of_natIso iso2.symm
    exact preservesColimitsOfShape_of_equiv (opOpEquivalence J).symm _
  ¬∑ convert preservesColimitsOfShape_of_op _ _
    exact preservesLimitsOfShape_of_natIso iso

instance preservesColimitsOfShape_pullback_of_toAffine {J : Type*} [Category J]
      {Y : Scheme.{u}} (f : X ‚ü∂ Y)
      [PreservesColimitsOfShape J (toAffine P Y)]
      [PreservesColimitsOfShape J (Affine.pullback f)] :
    PreservesColimitsOfShape J (Over.pullback P ‚ä§ f) := by
  have heq : MorphismProperty.Over.pullback P ‚ä§ f ‚ãô toAffine P X =
      toAffine P Y ‚ãô Affine.pullback f :=
    rfl
  have : PreservesColimitsOfShape J (MorphismProperty.Over.pullback P ‚ä§ f ‚ãô toAffine P X) := by
    rw [heq]
    infer_instance
  apply preservesColimitsOfShape_of_reflects_of_preserves
    (MorphismProperty.Over.pullback P ‚ä§ f) (toAffine P X)

lemma isPullback_openCoverOfBase_map {X Y Z T : Scheme.{u}} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
    (h : T ‚ü∂ pullback f g) (ùí∞ : Z.OpenCover) (i : ùí∞.J) :
    IsPullback (pullback.fst (h ‚â´ pullback.fst _ _) (pullback.fst f (ùí∞.map i)))
      (pullback.lift
        (pullback.map _ _ _ _ (h ‚â´ pullback.fst _ _) (pullback.snd _ _) f
          (by simp) pullback.condition)
        (pullback.map _ _ _ _ (h ‚â´ pullback.snd _ _) (pullback.snd _ _) f
          (by simp [pullback.condition]) pullback.condition)
        (by simp))
      h ((Scheme.Pullback.openCoverOfBase ùí∞ f g).map i) := by
  refine ‚ü®‚ü®?_‚ü©, ‚ü®PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_‚ü©‚ü©
  ¬∑ apply pullback.hom_ext <;> simp
  ¬∑ intro c
    refine pullback.lift c.fst
      (pullback.lift (c.snd ‚â´ pullback.fst _ _ ‚â´ pullback.fst _ _)
        (c.snd ‚â´ pullback.fst _ _ ‚â´ pullback.snd _ _)
        (by simp; rw [pullback.condition]))
        (by rw [pullback.lift_fst, c.condition_assoc]; simp)
  ¬∑ intro c
    rw [pullback.lift_fst]
  ¬∑ intro c
    refine pullback.hom_ext ?_ ?_
    ¬∑ simp only [Scheme.Pullback.openCoverOfBase_map, PullbackCone.œÄ_app_left,
      PullbackCone.œÄ_app_right, Category.assoc, limit.lift_œÄ, PullbackCone.mk_pt, cospan_right,
      PullbackCone.mk_œÄ_app, Functor.const_obj_obj, cospan_one]
      apply pullback.hom_ext
      ¬∑ simp only [pullback.map]
        simp_rw [Category.assoc, pullback.lift_fst, pullback.lift_fst_assoc, c.condition_assoc]
        simp
      ¬∑ simp_rw [Category.assoc, pullback.lift_snd, pullback.lift_snd_assoc, pullback.lift_snd]
    ¬∑ apply pullback.hom_ext
      ¬∑ simp_rw [Category.assoc, pullback.lift_snd_assoc, pullback.lift_fst,
          pullback.lift_fst_assoc]
        simp [c.condition_assoc]
      ¬∑ simp_rw [Category.assoc, pullback.lift_snd_assoc, pullback.lift_snd,
          pullback.lift_snd_assoc, pullback.lift_snd, pullback.condition]
  ¬∑ intro c m hfst hsnd
    apply pullback.hom_ext
    rw [hfst, pullback.lift_fst]
    apply pullback.hom_ext
    rw [pullback.lift_snd, pullback.lift_fst, ‚Üê hsnd]
    simp [pullback.condition]
    rw [pullback.lift_snd, pullback.lift_snd, ‚Üê hsnd]
    simp

section

variable {T : Type*} [Category T] (P Q : MorphismProperty T) [Q.IsMultiplicative] [Q.RespectsIso]
variable {X Y Z : T} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
variable [HasPullbacks T] [P.IsStableUnderBaseChange] [Q.IsStableUnderBaseChange]

noncomputable
def _root_.CategoryTheory.IsPullback.arrowMkSndIso
    {C : Type*} [Category C] {P X Y Z : C}
    {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}
    {P' : C} {fst' : P' ‚ü∂ X} {snd' : P' ‚ü∂ Y} (h : IsPullback fst snd f g)
    (h' : IsPullback fst' snd' f g) :
    Arrow.mk snd ‚âÖ Arrow.mk snd' :=
  Arrow.isoMk (h.isoIsPullback _ _ h') (Iso.refl _) (by simp)

noncomputable
def _root_.CategoryTheory.IsPullback.arrowMkFstIso
    {C : Type*} [Category C] {P X Y Z : C}
    {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}
    {P' : C} {fst' : P' ‚ü∂ X} {snd' : P' ‚ü∂ Y} (h : IsPullback fst snd f g)
    (h' : IsPullback fst' snd' f g) :
    Arrow.mk fst ‚âÖ Arrow.mk fst' :=
  Arrow.isoMk (h.isoIsPullback _ _ h') (Iso.refl _) (by simp)

noncomputable
def _root_.CategoryTheory.MorphismProperty.Over.pullbackCondition :
    Over.pullback P Q f ‚ãô Over.pullback P Q (pullback.fst f g) ‚âÖ
        Over.pullback P Q g ‚ãô Over.pullback P Q (pullback.snd f g) :=
  (MorphismProperty.Over.pullbackComp _ _).symm ‚â™‚â´
    MorphismProperty.Over.pullbackCongr pullback.condition ‚â™‚â´
    MorphismProperty.Over.pullbackComp _ _

lemma _root_.CategoryTheory.MorphismProperty.Over.colimit_post_pullback
  {J : Type*} [Category J] (D : J ‚•§ P.Over Q Z) [HasColimit D]
  [HasColimit (D ‚ãô Over.pullback P Q f)]
  [HasColimit ((D ‚ãô Over.pullback P Q f) ‚ãô Over.pullback P Q (pullback.fst f g))]
  [HasColimit (D ‚ãô MorphismProperty.Over.pullback P Q g)]
  [HasColimit ((D ‚ãô MorphismProperty.Over.pullback P Q g) ‚ãô
    MorphismProperty.Over.pullback P Q (pullback.snd f g))]
  [HasColimit (D ‚ãô MorphismProperty.Over.pullback P Q f ‚ãô
    MorphismProperty.Over.pullback P Q (pullback.fst f g))] :
    colimit.post (D ‚ãô Over.pullback P Q f) (Over.pullback P Q (pullback.fst f g)) ‚â´
    (Over.pullback P Q (pullback.fst f g)).map (colimit.post D (Over.pullback P Q f)) =
    (HasColimit.isoOfNatIso
      (Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft D (Over.pullbackCondition P Q f g) ‚â™‚â´
        (Functor.associator _ _ _).symm)).hom ‚â´
      colimit.post (D ‚ãô Over.pullback P Q g) _ ‚â´
      (MorphismProperty.Over.pullback P Q (pullback.snd f g)).map
        (colimit.post D (MorphismProperty.Over.pullback P Q g)) ‚â´
      ((Over.pullbackCondition P Q f g).app (colimit D)).inv := by
  simp only [colimit.post_post, Functor.comp_obj, Iso.app_inv]
  apply colimit.hom_ext
  intro j
  simp only [Functor.comp_obj, colimit.Œπ_post, Functor.comp_map, HasColimit.isoOfNatIso_Œπ_hom_assoc,
    Iso.trans_hom, isoWhiskerLeft_hom, Iso.symm_hom, NatTrans.comp_app, Functor.associator_hom_app,
    whiskerLeft_app, Functor.associator_inv_app, Category.comp_id, Category.id_comp,
    colimit.Œπ_post_assoc]
  rw [‚Üê Functor.map_comp_assoc, colimit.Œπ_post, ‚Üê Functor.comp_map, ‚Üê Functor.comp_map]
  rw [NatTrans.naturality]
  simp

/-- If `F` is naturally isomorphic to `F'` they induce isomorphic `colimit.post` maps. -/
noncomputable
def _root_.CategoryTheory.Limits.colimit.arrowMkPostIsoOfIso {J C D : Type*} [Category J]
    [Category C] [Category D] (K : J ‚•§ C) (F F' : C ‚•§ D)
    (e : F ‚âÖ F') [HasColimit K] [HasColimit (K ‚ãô F)] [HasColimit (K ‚ãô F')] :
    Arrow.mk (colimit.post K F) ‚âÖ Arrow.mk (colimit.post K F') :=
  Arrow.isoMk (HasColimit.isoOfNatIso <| isoWhiskerLeft K e) (e.app _)
    (by apply colimit.hom_ext; simp)

end

section

variable (P : MorphismProperty Scheme.{u}) [IsLocalAtTarget P]

lemma _root_.AlgebraicGeometry.IsLocalAtTarget.iff_of_openCover_of_over
    {X Y S : Scheme.{u}} [X.Over S] [Y.Over S]
    (f : X ‚ü∂ Y) [f.IsOver S] (ùí∞ : S.OpenCover) :
    P f ‚Üî ‚àÄ i : ùí∞.J,
      P (pullback.map (X ‚Üò S) (ùí∞.map i) (Y ‚Üò S) (ùí∞.map i) f (ùüô _) (ùüô _) (by simp) (by simp)) := by
  have heq (i : ùí∞.J) : ((Scheme.Cover.pullbackCover ùí∞ (Y ‚Üò S)).pullbackHom f i) =
      (pullbackRightPullbackFstIso _ _ _).hom ‚â´ (pullback.congrHom (by simp) rfl).hom ‚â´
      pullback.map (X ‚Üò S) (ùí∞.map i) (Y ‚Üò S) (ùí∞.map i) f (ùüô _) (ùüô _) (by simp) (by simp) := by
    apply pullback.hom_ext <;> simp [Scheme.Cover.pullbackHom, pullback.condition]
  refine ‚ü®fun hf i ‚Ü¶ ?_, fun H ‚Ü¶ ?_‚ü©
  ¬∑ have : P ((Scheme.Cover.pullbackCover ùí∞ (Y ‚Üò S)).pullbackHom f i) :=
      IsLocalAtTarget.of_isPullback (.of_hasPullback _ _) hf
    rwa [heq, P.cancel_left_of_respectsIso, P.cancel_left_of_respectsIso] at this
  ¬∑ rw [IsLocalAtTarget.iff_of_openCover (P := P) (ùí∞.pullbackCover (Y ‚Üò S))]
    intro i
    have heq : ((Scheme.Cover.pullbackCover ùí∞ (Y ‚Üò S)).pullbackHom f i) =
        (pullbackRightPullbackFstIso _ _ _).hom ‚â´ (pullback.congrHom (by simp) rfl).hom ‚â´
        pullback.map (X ‚Üò S) (ùí∞.map i) (Y ‚Üò S) (ùí∞.map i) f (ùüô _) (ùüô _) (by simp) (by simp) := by
      apply pullback.hom_ext <;> simp [Scheme.Cover.pullbackHom, pullback.condition]
    rw [heq, P.cancel_left_of_respectsIso, P.cancel_left_of_respectsIso]
    exact H i

variable {W Q : MorphismProperty Scheme.{u}} [Q.IsMultiplicative]
variable [W.IsStableUnderBaseChange] [Q.IsStableUnderBaseChange]

variable {P} in
lemma _root_.AlgebraicGeometry.IsLocalAtTarget.left_iff_of_openCover
    {S : Scheme.{u}} {X Y : W.Over Q S} {f : X ‚ü∂ Y} (ùí∞ : S.OpenCover) :
    P f.left ‚Üî ‚àÄ i : ùí∞.J,
      P ((MorphismProperty.Over.pullback W Q (ùí∞.map i)).map f).left :=
  AlgebraicGeometry.IsLocalAtTarget.iff_of_openCover_of_over ..

end

nonrec theorem preservesFiniteColimits_pullback (hQi : RingHom.RespectsIso Q)
    (hQp : RingHom.HasFiniteProducts Q) (hQe : RingHom.HasEqualizers Q)
    [(RingHom.toMorphismProperty Q).IsStableUnderCobaseChange]
    [‚àÄ (R S : CommRingCat.{u}) (f : R ‚ü∂ S), PreservesFiniteLimits
      (Under.pushout (RingHom.toMorphismProperty Q) ‚ä§ f)]
    {Y : Scheme.{u}} (f : X ‚ü∂ Y) :
    PreservesFiniteColimits (Over.pullback P ‚ä§ f) := by
  have (S : Scheme.{u}) : HasFiniteColimits (P.Over ‚ä§ S) := hasFiniteColimits P hQi hQp hQe
  constructor
  intro J _ _
  constructor
  intro D
  suffices h : IsIso (colimit.post D (MorphismProperty.Over.pullback P ‚ä§ f)).left by
    have : IsIso (colimit.post D (MorphismProperty.Over.pullback P ‚ä§ f)) := by
      convert isIso_of_reflects_iso _ (Over.forget P ‚ä§ X ‚ãô Over.forget X)
      exact h
    apply preservesColimit_of_isIso_post
  show isomorphisms Scheme.{u} _
  wlog H : (‚àÉ R, Y = Spec R) ‚àß ‚àÉ S, X = Spec S generalizing X Y D f
  ¬∑ let ùí∞X : X.OpenCover :=
      (Scheme.OpenCover.affineRefinement (Y.affineCover.pullbackCover f)).openCover
    rw [IsLocalAtTarget.left_iff_of_openCover (P := isomorphisms Scheme) ùí∞X]
    intro i
    let u·µ¢ : Y.affineCover.obj i.1 ‚ü∂ Y := Y.affineCover.map i.1
    have _ : PreservesFiniteColimits (toAffine P X) :=
      preservesFiniteColimits_toAffine P hQi hQp hQe
    have _ : PreservesFiniteColimits (toAffine P Y) :=
      preservesFiniteColimits_toAffine P hQi hQp hQe
    rw [‚Üê cancel_left_of_respectsIso (isomorphisms Scheme)
      (colimit.post (D ‚ãô Over.pullback P ‚ä§ f) (Over.pullback P ‚ä§ (ùí∞X.map i))).left]
    erw [‚Üê MorphismProperty.Comma.comp_left]
    simp only [MorphismProperty.Over.pullback_obj_left, MorphismProperty.Over.pullback_obj_hom,
      colimit.post_post]
    have heq : ùí∞X.map i = (Scheme.OpenCover.fromAffineRefinement _).app i ‚â´ pullback.fst f u·µ¢ := by
      convert (Scheme.OpenCover.fromAffineRefinement (Y.affineCover.pullbackCover f)).w i
    let natiso :
        Over.pullback P ‚ä§ f ‚ãô Over.pullback P ‚ä§ (ùí∞X.map i) ‚âÖ
          Over.pullback P ‚ä§ u·µ¢ ‚ãô
            Over.pullback P ‚ä§
              ((Scheme.OpenCover.fromAffineRefinement _).app i ‚â´ pullback.snd f u·µ¢) :=
      (MorphismProperty.Over.pullbackComp _ _).symm ‚â™‚â´
        MorphismProperty.Over.pullbackCongr
        (by rw [Category.assoc, ‚Üê pullback.condition, heq, Category.assoc]) ‚â™‚â´
        (MorphismProperty.Over.pullbackComp _ _)
    let e := colimit.arrowMkPostIsoOfIso D _ _ natiso
    have : IsIso ((colimit.post D (Over.pullback P ‚ä§ f ‚ãô Over.pullback P ‚ä§ (ùí∞X.map i)))) := by
      show isomorphisms _ _
      rw [(isomorphisms _).arrow_mk_iso_iff e, ‚Üê colimit.post_post,
        (isomorphisms _).cancel_right_of_respectsIso]
      convert isIso_of_reflects_iso _ (Over.forget P ‚ä§ _ ‚ãô Over.forget _)
      exact this _ ‚ü®‚ü®_, rfl‚ü©, ‚ü®_, rfl‚ü©‚ü©
    simp only [isomorphisms.iff]
    infer_instance
  obtain ‚ü®‚ü®R, rfl‚ü©, ‚ü®S, rfl‚ü©‚ü© := H
  obtain ‚ü®œÜ, rfl‚ü© := Spec.map_surjective f
  have : PreservesColimitsOfShape J (MorphismProperty.Over.pullback P ‚ä§ (Spec.map œÜ)) := by
    rw [preservesColimitsOfShape_pullback_iff_preservesLimitsOfShape _ hQi]
    infer_instance
  simp only [isomorphisms.iff]
  infer_instance

end AffineAnd

end AlgebraicGeometry
